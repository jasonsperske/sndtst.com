<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv='content-type' content='text/html;charset=UTF-8' />
    <title>Scout's App</title>
    <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1'>
    <link type='text/css' href='/static/css/sndtst.min.css' rel='stylesheet' />
    <link rel="apple-touch-icon" href="/static/images/touch-icon-iphone.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/static/images/touch-icon-ipad.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/static/images/touch-icon-iphone-retina.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/static/images/touch-icon-ipad-retina.png">
    <link rel="shortcut icon" href="/static/favicon.ico">
  </head>
	<body>
    <header>
      <div class='container'>
        <div class="navbar navbar-dark navbar-expand-md">
          <div class="container d-flex justify-content-between">
            <a href="/" class="navbar-brand d-flex align-items-center">
              <strong>Scout's App</strong>
            </a>
          </div>
        </div>
      </div>
    </header>
    <main role="main">
      <div class="container">
        <ul id="locations"></ul>
        <button type="button" id="AddLocation" class="btn btn-xs btn-info">+</button>
      </div>
    </main>
    <script type="module">
      import LatLon from 'https://cdn.jsdelivr.net/npm/geodesy@2/latlon-ellipsoidal-vincenty.js';

      class PointOfIntrest {
        constructor(record) {
          this.label = record.label;
          this.lat = record.lat;
          this.lon = record.lon;
          this.point = LatLon.parse(this.lat, this.lon);
        }
        toJSON() {
          let {label, lat, lon} = this;
          return {label, lat, lon};
        }
        distanceTo(position) {
          return parseFloat(this.point.distanceTo(position));
        }
      }
      class PointOfIntrestFrom {
        constructor(point, position) {
          this.point_ = point;
          this.distanceTo_ = point.distanceTo(position);
        }
        get label() {
          return this.point_.label;
        }
        get distanceTo() {
          return this.distanceTo_;
        }
      }

      class LocationsStorage {
        constructor(storageName) {
          this.storageName_ = storageName || 'locations';
          this.points_ = this.load_();
        }
        load_() {
          let data = window.localStorage.getItem(this.storageName_);
          if (data) {
            return JSON.parse(data).map(d => new PointOfIntrest(d));
          } else {
            return [];
          }
        }
        save_() {
          window.localStorage.setItem(this.storageName_, JSON.stringify(this.points_));
        }
        add(label, position) {
          let newPoint = new PointOfIntrest({
            label: label,
            lat: position.latitude,
            lon: position.longitude
          });

          this.points_.push(newPoint);
          this.save_();

          return newPoint;
        }
        forEach(action, position) {
          let pointsFrom = this.points_.map(p => new PointOfIntrestFrom(p, position));
          pointsFrom.sort((a, b) => a.distanceTo - b.distanceTo);
          pointsFrom.forEach(action);
        }
      }

      class UI {
        constructor() {
          this.storage_ = new LocationsStorage('locations');
          this.addLocationButton_ = document.getElementById('AddLocation');
          this.listOfLocations_ = document.getElementById('locations');

          this.addLocationButton_.onclick = () => {
            this.addLocationButton_.disabled = true;
            navigator.geolocation.getCurrentPosition(
              (position) => {
                const label = prompt("What do you call this place?");
                if (label.length > 0) {
                  this.update(this.storage_.add(label, position.coords));
                }
                this.addLocationButton_.disabled = true;
              }, () => {
                alert('Position could not be determined.');
                this.addLocationButton_.disabled = true;
              }, {
                enableHighAccuracy: true
              }
            );
          }
          navigator.geolocation.watchPosition(
            (position) => {
              this.update(LatLon.parse(position.coords.latitude, position.coords.longitude));
            }, () => {
              alert('Position could not be determined.');
            }, {
              enableHighAccuracy: true
            }
          );
        }

        createRow_(point) {
          const row = document.createElement('li');
          const distance = document.createElement('span');
          distance.innerText = point.distanceTo + ' m';
          row.innerText = point.label + " ";
          row.appendChild(distance);
          return row;
        }

        update(position) {
          this.listOfLocations_.innerHTML = '';
          this.storage_.forEach((location, index) => {
            this.listOfLocations_.appendChild(this.createRow_(location));
          }, position);
        }
      }

      const ui = new UI();
    </script>
  </body>
</html>
